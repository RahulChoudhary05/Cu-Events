/**
 * @fileoverview A class to manage state of generating a code path.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const CodePathSegment = require("./code-path-segment"),
    ForkContext = require("./fork-context");

//-----------------------------------------------------------------------------
// Contexts
//-----------------------------------------------------------------------------

/**
 * Represents the context in which a `break` statement can be used.
 *
 * A `break` statement without a label is only valid in a few places in
 * JavaScript: any type of loop or a `switch` statement. Otherwise, `break`
 * without a label causes a syntax error. For these contexts, `breakable` is
 * set to `true` to indicate that a `break` without a label is valid.
 *
 * However, a `break` statement with a label is also valid inside of a labeled
 * statement. For example, this is valid:
 *
 *     a : {
 *         break a;
 *     }
 *
 * The `breakable` property is set false for labeled statements to indicate
 * that `break` without a label is invalid.
 */
class BreakContext {

    /**
     * Creates a new instance.
     * @param {BreakContext} upperContext The previous `BreakContext`.
     * @param {boolean} breakable Indicates if we are inside a statement where
     *      `break` without a label will exit the statement.
     * @param {string|null} label The label for the statement.
     * @param {ForkContext} forkContext The current fork context.
     */
    constructor(upperContext, breakable, label, forkContext) {

        /**
         * The previous `BreakContext`
         * @type {BreakContext}
         */
        this.upper = upperContext;

        /**
         * Indicates if we are inside a statement where `break` without a label
         * will exit the statement.
         * @type {boolean}
         */
        this.breakable = breakable;

        /**
         * The label associated with the statement.
         * @type {string|null}
         */
        this.label = label;

        /**
         * The fork context for the `break`.
         * @type {ForkContext}
         */
        this.brokenForkContext = ForkContext.newEmpty(forkContext);
    }
}

/**
 * Represents the context for `ChainExpression` nodes.
 */
class ChainContext {

    /**
     * Creates a new instance.
     * @param {ChainContext} upperContext The previous `ChainContext`.
     */
    constructor(upperContext) {

        /**
         * The previous `ChainContext`
         * @type {ChainContext}
         */
        this.upper = upperContext;

        /**
         * The number of choice contexts inside of the `ChainContext`.
         * @type {number}
         */
        this.choiceContextCount = 0;

    }
}

/**
 * Represents a choice in the code path.
 *
 * Choices are created by logical operators such as `&&`, loops, conditionals,
 * and `if` statements. This is the point at which the code path has a choice of
 * which direction to go.
 *
 * The result of a choice might be in the left (test) expression of another choice,
 * and in that case, may create a new fork. For example, `a || b` is a choice
 * but does not create a new fork because the result of the expression is
 * not used as the test expression in another expression. In this case,
 * `isForkingAsResult` is false. In the expression `a || b || c`, the `a || b`
 * expression appears as the test expression for `|| c`, so the
 * result of `a || b` creates a fork because execution may or may not
 * continue to `|| c`. `isForkingAsResult` for `a || b` in this case is true
 * while `isForkingAsResult` for `|| c` is false. (`isForkingAsResult` is always
 * false for `if` statements, conditional expressions, and loops.)
 *
 * All of the choices except one (`??`) operate on a true/false fork, meaning if
 * true go one way and if false go the other (tracked by `trueForkContext` and
 * `falseForkContext`). The `??` operator doesn't operate on true/false because
 * the left expression is evaluated to be nullish or not, so only if nullish do
 * we fork to the right expression (tracked by `nullishForkContext`).
 */
class ChoiceContext {

    /**
     * Creates a new instance.
     * @param {ChoiceContext} upperContext The previous `ChoiceContext`.
     * @param {string} kind The kind of choice. If it's a logical or assignment expression, this
     *      is `"&&"` or `"||"` or `"??"`; if it's an `if` statement or
     *      conditional expression, this is `"test"`; otherwise, this is `"loop"`.
     * @param {boolean} isForkingAsResult Indicates if the result of the choice
     *      creates a fork.
     * @param {ForkContext} forkContext The containing `ForkContext`.
     */
    constructor(upperContext, kind, isForkingAsResult, forkContext) {

        /**
         * The previous `ChoiceContext`
         * @type {ChoiceContext}
         */
        this.upper = upperContext;

        /**
         * The kind of choice. If it's a logical or assignment expression, this
         * is `"&&"` or `"||"` or `"??"`; if it's an `if` statement or
         * conditional expression, this is `"test"`; otherwise, this is `"loop"`.
         * @type {string}
         */
        this.kind = kind;

        /**
         * Indicates if the result of the choice forks the code path.
         * @type {boolean}
         */
        this.isForkingAsResult = isForkingAsResult;

        /**
         * The fork context for the `true` path of the choice.
         * @type {ForkContext}
         */
        this.trueForkContext = ForkContext.newEmpty(forkContext);

        /**
         * The fork context for the `false` path of the choice.
         * @type {ForkContext}
         */
        this.falseForkContext = ForkContext.newEmpty(forkContext);

        /**
         * The fork context for when the choice result is `null` or `undefined`.
         * @type {ForkContext}
         */
        this.nullishForkContext = ForkContext.newEmpty(forkContext);

        /**
         * Indicates if any of `trueForkContext`, `falseForkContext`, or
         * `nullishForkContext` have been updated with segments from a child context.
         * @type {boolean}
         */
        this.processed = false;
    }

}

/**
 * Base class for all loop contexts.
 */
class LoopContextBase {

    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string} type The AST node's `type` for the loop.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     */
    constructor(upperContext, type, label, breakContext) {

        /**
         * The previous `LoopContext`.
         * @type {LoopContext}
         */
        this.upper = upperContext;

        /**
         * The AST node's `type` for the loop.
         * @type {string}
         */
        this.type = type;

        /**
         * The label for the loop from an enclosing `LabeledStatement`.
         * @type {string|null}
         */
        this.label = label;

        /**
         * The fork context for when `break` is encountered.
         * @type {ForkContext}
         */
        this.brokenForkContext = breakContext.brokenForkContext;
    }
}

/**
 * Represents the context for a `while` loop.
 */
class WhileLoopContext extends LoopContextBase {

    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     */
    constructor(upperContext, label, breakContext) {
        super(upperContext, "WhileStatement", label, breakContext);

        /**
         * The hardcoded literal boolean test condition for
         * the loop. Used to catch infinite or skipped loops.
         * @type {boolean|undefined}
         */
        this.test = void 0;

        /**
         * The segments representing the test condition where `continue` will
         * jump to. The test condition will typically have just one segment but
         * it's possible for there to be more than one.
         * @type {Array<CodePathSegment>|null}
         */
        this.continueDestSegments = null;
    }
}

/**
 * Represents the context for a `do-while` loop.
 */
class DoWhileLoopContext extends LoopContextBase {

    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     * @param {ForkContext} forkContext The enclosing fork context.
     */
    constructor(upperContext, label, breakContext, forkContext) {
        super(upperContext, "DoWhileStatement", label, breakContext);

        /**
         * The hardcoded literal boolean test condition for
         * the loop. Used to catch infinite or skipped loops.
         * @type {boolean|undefined}
         */
        this.test = void 0;

        /**
         * The segments at the start of the loop body. This is the only loop
         * where the test comes at the end, so the first iteration always
         * happens and we need a reference to the first statements.
         * @type {Array<CodePathSegment>|null}
         */
        this.entrySegments = null;

        /**
         * The fork context to follow when a `continue` is found.
         * @type {ForkContext}
         */
        this.continueForkContext = ForkContext.newEmpty(forkContext);
    }
}

/**
 * Represents the context for a `for` loop.
 */
class ForLoopContext extends LoopContextBase {

    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     */
    constructor(upperContext, label, breakContext) {
        super(upperContext, "ForStatement", label, breakContext);

        /**
         * The hardcoded literal boolean test condition for
         * the loop. Used to catch infinite or skipped loops.
         * @type {boolean|undefined}
         */
        this.test = void 0;

        /**
         * The end of the init expression. This may change during the lifetime
         * of the instance as we traverse the loop because some loops don't have
         * an init expression.
         * @type {Array<CodePathSegment>|null}
         */
        this.endOfInitSegments = null;

        /**
         * The start of the test expression. This may change during the lifetime
         * of the instance as we traverse the loop because some loops don't have
         * a test expression.
         * @type {Array<CodePathSegment>|null}
         */
        this.testSegments = null;

        /**
         * The end of the test expression. This may change during the lifetime
         * of the instance as we traverse the loop because some loops don't have
         * a test expression.
         * @type {Array<CodePathSegment>|null}
         */
        this.endOfTestSegments = null;

        /**
         * The start of the update expression. This may change during the lifetime
         * of the instance as we traverse the loop because some loops don't have
         * an update expression.
         * @type {Array<CodePathSegment>|null}
         */
        this.updateSegments = null;

        /**
         * The end of the update expresion. This may change during the lifetime
         * of the instance as we traverse the loop because some loops don't have
         * an update expression.
         * @type {Array<CodePathSegment>|null}
         */
        this.endOfUpdateSegments = null;

        /**
         * The segments representing the test condition where `continue` will
         * jump to. The test condition will typically have just one segment but
         * it's possible for there to be more than one. This may change during the
         * lifetime of the instance as we traverse the loop because some loops
         * don't have an update expression. When there is an update expression, this
         * will end up pointing to that expression; otherwise it will end up pointing
         * to the test expression.
         * @type {Array<CodePathSegment>|null}
         */
        this.continueDestSegments = null;
    }
}

/**
 * Represents the context for a `for-in` loop.
 *
 * Terminology:
 * - "left" means the part of the loop to the left of the `in` keyword. For
 *   example, in `for (var x in y)`, the left is `var x`.
 * - "right" means the part of the loop to the right of the `in` keyword. For
 *   example, in `for (var x in y)`, the right is `y`.
 */
class ForInLoopContext extends LoopContextBase {

    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     */
    constructor(upperContext, label, breakContext) {
        super(upperContext, "ForInStatement", label, breakContext);

        /**
         * The segments that came immediately before the start of the loop.
         * This allows you to traverse backwards out of the loop into the
         * surrounding code. This is necessary to evaluate the right expression
         * correctly, as it must be evaluated in the same way as the left
         * expression, but the pointer to these segments would otherwise be
         * lost if not stored on the instance. Once the right expression has
         * been evaluated, this property is no longer used.
         * @type {Array<CodePathSegment>|null}
         */
        this.prevSegments = null;

        /**
         * Segments representing the start of everything to the left of the
         * `in` keyword. This can be used to move forward towards
         * `endOfLeftSegments`. `leftSegments` and `endOfLeftSegments` are
         * effectively the head and tail of a doubly-linked list.
         * @type {Array<CodePathSegment>|null}
         */
        this.leftSegments = null;

        /**
         * Segments representing the end of everything to the left of the
         * `in` keyword. This can be used to move backward towards `leftSegments`.
         * `leftSegments` and `endOfLeftSegments` are effectively the head
         * and tail of a doubly-linked list.
         * @type {Array<CodePathSegment>|null}
         */
        this.endOfLeftSegments = null;

        /**
         * The segments representing the left expression where `continue` will
         * jump to. In `for-in` loops, `continue` must always re-execute the
         * left expression each time through the loop. This contains the same
         * segments as `leftSegments`, but is duplicated here so each loop
         * context has the same property pointing to where `continue` should
         * end up.
         * @type {Array<CodePathSegment>|null}
         */
        this.continueDestSegments = null;
    }
}

/**
 * Represents the context for a `for-of` loop.
 */
class ForOfLoopContext extends LoopContextBase {

    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     */
    constructor(upperContext, label, breakContext) {
        super(upperContext, "ForOfStatement", label, breakContext);

        /**
         * The segments that came immediately before the start of the loop.
         * This allows you to traverse backwards out of the loop into the
         * surrounding code. This is necessary to evaluate the right expression
         * correctly, as it must be evaluated in the same way as the left
         * expression, but the pointer to these segments would otherwise be
         * lost if not stored on the instance. Once the right expression has
         * been evaluated, this property is no longer used.
         * @type {Array<CodePathSegment>|null}
         */
        this.prevSegments = null;

        /**
         * Segments representing the start of everything to the left of the
         * `of` keyword. This can be used to move forward towards
         * `endOfLeftSegments`. `leftSegments` and `endOfLeftSegments` are
         * effectively the head and tail of a doubly-linked list.
         * @type {Array<CodePathSegment>|null}
         */
        this.leftSegments = null;

        /**
         * Segments representing the end of everything to the left of the
         * `of` keyword. This can be used to move backward towards `leftSegments`.
         * `leftSegments` and `endOfLeftSegments` are effectively the head
         * and tail of a doubly-linked list.
         * @type {Array<CodePathSegment>|null}
         */
        this.endOfLeftSegments = null;

        /**
         * The segments representing the left expression where `continue` will
         * jump to. In `for-in` loops, `continue` must always re-execute the
         * left expression each time through the loop. This contains the same
         * segments as `leftSegments`, but is duplicated here so each loop
         * context has the same property pointing to where `continue` should
         * end up.
         * @type {Array<CodePathSegment>|null}
         */
        this.continueDestSegments = null;
    }
}

/**
 * Represents the context for any loop.
 * @typedef {WhileLoopContext|DoWhileLoopContext|ForLoopContext|ForInLoopContext|ForOfLoopContext} LoopContext
 */

/**
 * Represents the context for a `switch` statement.
 */
class SwitchContext {

    /**
     * Creates a new instance.
     * @param {SwitchContext} upperContext The previous context.
     * @param {boolean} hasCase Indicates if there is at least one `case` statement.
     *      `default` doesn't count.
     */
    constructor(upperContext, hasCase) {

        /**
         * The previous context.
         * @type {SwitchContext}
         */
        this.upper = upperContext;

        /**
         * Indicates if there is at least one `case` statement. `default` doesn't count.
         * @type {boolean}
         */
        this.hasCase = hasCase;

        /**
         * The `default` keyword.
         * @type {Array<CodePathSegment>|null}
         */
        this.defaultSegments = null;

        /**
         * The default case body starting segments.
         * @type {Array<CodePathSegment>|null}
         */
        this.defaultBodySegments = null;

        /**
         * Indicates if a `default` case and is empty exists.
         * @type {boolean}
         */
        this.foundEmptyDefault = false;

        /**
         * Indicates that a `default` exists and is the last case.
         * @type {boolean}
         */
        this.lastIsDefault = false;

        /**
         * The number of fork contexts created. This is equivalent to the
         * number of `case` statements plus a `default` statement (if present).
         * @type {number}
         */
        this.forkCount = 0;
    }
}

/**
 * Represents the context for a `try` statement.
 */
class TryContext {

    /**
     * Creates a new instance.
     * @param {TryContext} upperContext The previous context.
     * @param {boolean} hasFinalizer Indicates if the `try` statement has a
     *      `finally` block.
     * @param {ForkContext} forkContext The enclosing fork context.
     */
    constructor(upperContext, hasFinalizer, forkContext) {

        /**
         * The previous context.
         * @type {TryContext}
         */
        this.upper = upperContext;

        /**
         * Indicates if the `try` statement has a `finally` block.
         * @type {boolean}
         */
        this.hasFinalizer = hasFinalizer;

        /**
         * Tracks the traversal position inside of the `try` statement. This is
         * used to help determine the context necessary to create paths because
         * a `try` statement may or may not have `catch` or `finally` blocks,
         * and code paths behave differently in those blocks.
         * @type {"try"|"catch"|"finally"}
         */
        this.position = "try";

        /**
         * If the `try` statement has a `finally` block, this affects how a
         * `return` statement behaves in the `try` block. Without `finally`,
         * `return` behaves as usual and doesn't require a fork; with `finally`,
         * `return` forks into the `finally` block, so we need a fork context
         * to track it.
         * @type {ForkContext|null}
         */
        this.returnedForkContext = hasFinalizer
            ? ForkContext.newEmpty(forkContext)
            : null;

        /**
         * When a `throw` occurs inside of a `try` block, the code path forks
         * into the `catch` or `finally` blocks, and this fork context tracks
         * that path.
         * @type {ForkContext}
         */
        this.thrownForkContext = ForkContext.newEmpty(forkContext);

        /**
         * Indicates if the last segment in the `try` block is reachable.
         * @type {boolean}
         */
        this.lastOfTryIsReachable = false;

        /**
         * Indicates if the last segment in the `catch` block is reachable.
         * @type {boolean}
         */
        this.lastOfCatchIsReachable = false;
    }
}

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Adds given segments into the `dest` array.
 * If the `others` array does not include the given segments, adds to the `all`
 * array as well.
 *
 * This adds only reachable and used segments.
 * @param {CodePathSegment[]} dest A destination array (`returnedSegments` or `thrownSegments`).
 * @param {CodePathSegment[]} others Another destination array (`returnedSegments` or `thrownSegments`).
 * @param {CodePathSegment[]} all The unified destination array (`finalSegments`).
 * @param {CodePathSegment[]} segments Segments to add.
 * @returns {void}
 */
function addToReturnedOrThrown(dest, others, all, segments) {
    for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];

        dest.push(segment);
        if (!others.includes(segment)) {
            all.push(segment);
        }
    }
}

/**
 * Gets a loop context for a `continue` statement based on a given label.
 * @param {CodePathState} state The state to search within.
 * @param {string|null} label The label of a `continue` statement.
 * @returns {LoopContext} A loop-context for a `continue` statement.
 */
function getContinueContext(state, label) {
    if (!label) {
        return state.loopContext;
    }

    let context = state.loopContext;

    while (context) {
        if (context.label === label) {
            return context;
        }
        context = context.upper;
    }

    /* c8 ignore next */
    return null;
}

/**
 * Gets a context for a `break` statement.
 * @param {CodePathState} state The state to search within.
 * @param {string|null} label The label of a `break` statement.
 * @returns {BreakContext} A context for a `break` statement.
 */
function getBreakContext(state, label) {
    let context = state.breakContext;

    while (context) {
        if (label ? context.label === label : context.breakable) {
            return context;
        }
        context = context.upper;
    }

    /* c8 ignore next */
    return null;
}

/**
 * Gets a context for a `return` statement. There is just one special case:
 * if there is a `try` statement with a `finally` block, because that alters
 * how `return` behaves; otherwise, this just passes through the given state.
 * @param {CodePathState} state The state to search within
 * @returns {TryContext|CodePathState} A context for a `return` statement.
 */
function getReturnContext(state) {
    let context = state.tryContext;

    while (context) {
        if (context.hasFinalizer && context.position !== "finally") {
            return context;
        }
        context = context.upper;
    }

    return state;
}

/**
 * Gets a context for a `throw` statement. There is just one special case:
 * if there is a `try` statement with a `finally` block and we are inside of
 * a `catch` because that changes how `throw` behaves; otherwise, this just
 * passes through the given state.
 * @param {CodePathState} state The state to search within.
 * @returns {TryContext|CodePathState} A context for a `throw` statement.
 */
function getThrowContext(state) {
    let context = state.tryContext;

    while (context) {
        if (context.position === "try" ||
            (context.hasFinalizer && context.position === "catch")
        ) {
            return context;
        }
        context = context.upper;
    }

    return state;
}

/**
 * Removes a given value from a given array.
 * @param {any[]} elements An array to remove the specific element.
 * @param {any} value The value to be removed.
 * @returns {void}
 */
function removeFromArray(elements, value) {
    elements.splice(elements.indexOf(value), 1);
}

/**
 * Disconnect given segments.
 *
 * This is used in a process for switch statements.
 * If there is the "default" chunk before other cases, the order is different
 * between node's and running's.
 * @param {CodePathSegment[]} prevSegments Forward segments to disconnect.
 * @param {CodePathSegment[]} nextSegments Backward segments to disconnect.
 * @returns {void}
 */
function disconnectSegments(prevSegments, nextSegments) {
    for (let i = 0; i < prevSegments.length; ++i) {
        const prevSegment = prevSegments[i];
        const nextSegment = nextSegments[i];

        removeFromArray(prevSegment.nextSegments, nextSegment);
        removeFromArray(prevSegment.allNextSegments, nextSegment);
        removeFromArray(nextSegment.prevSegments, prevSegment);
        removeFromArray(nextSegment.allPrevSegments, prevSegment);
    }
}

/**
 * Creates looping path between two arrays of segments, ensuring that there are
 * paths going between matching segments in the arrays.
 * @param {CodePathState} state The state to operate on.
 * @param {CodePathSegment[]} unflattenedFromSegments Segments which are source.
 * @param {CodePathSegment[]} unflattenedToSegments Segments which are destination.
 * @returns {void}
 */
function makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {

    const fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);
    const toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);
    const end = Math.min(fromSegments.length, toSegments.length);

    /*
     * This loop effectively updates a doubly-linked list between two collections
     * of segments making sure that segments in the same array indices are
     * combined to create a path.
     */
    for (let i = 0; i < end; ++i) {

        // get the segments in matching array indices
        const fromSegment = fromSegments[i];
        const toSegment = toSegments[i];

        /*
         * If the destination segment is reachable, then create a path from the
         * source segment to the destination segment.
         */
        if (toSegment.reachable) {
            fromSegment.nextSegments.push(toSegment);
        }

        /*
         * If the source segment is reachable, then create a path from the
         * destination segment back to the source segment.
         */
        if (fromSegment.reachable) {
            toSegment.prevSegments.push(fromSegment);
        }

        /*
         * Also update the arrays that don't care if the segments are reachable
         * or not. This should always happen regardless of anything else.
         */
        fromSegment.allNextSegments.push(toSegment);
        toSegment.allPrevSegments.push(fromSegment);

        /*
         * If the destination segment has at least two previous segments in its
         * path then that means there was one previous segment before this iteration
         * of the loop was executed. So, we need to mark the source segment as
         * looped.
         */
        if (toSegment.allPrevSegments.length >= 2) {
            CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);
        }

        // let the code path analyzer know that there's been a loop created
        state.notifyLooped(fromSegment, toSegment);
    }
}

/**
 * Finalizes segments of `test` chunk of a ForStatement.
 *
 * - Adds `false` paths to paths which are leaving from the loop.
 * - Sets `true` paths to paths which go to the body.
 * @param {LoopContext} context A loop context to modify.
 * @param {ChoiceContext} choiceContext A choice context of this loop.
 * @param {CodePathSegment[]} head The current head paths.
 * @returns {void}
 */
function finalizeTestSegmentsOfFor(context, choiceContext, head) {

    /*
     * If this choice context doesn't already contain paths from a
     * child context, then add the current head to each potential path.
     */
    if (!choiceContext.processed) {
        choiceContext.trueForkContext.add(head);
        choiceContext.falseForkContext.add(head);
        choiceContext.nullishForkContext.add(head);
    }

    /*
     * If the test condition isn't a hardcoded truthy value, then `break`
     * must follow the same path as if the test condition is false. To represent
     * that, we append the path for when the loop test is false (represented by
     * `falseForkContext`) to the `brokenForkContext`.
     */
    if (context.test !== true) {
        context.brokenForkContext.addAll(choiceContext.falseForkContext);
    }

    context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * A class which manages state to analyze code paths.
 */
class CodePathState {

    /**
     * Creates a new instance.
     * @param {IdGenerator} idGenerator An id generator to generate id for code
     *   path segments.
     * @param {Function} onLooped A callback function to notify looping.
     */
    constructor(idGenerator, onLooped) {

        /**
         * The ID generator to use when creating new segments.
         * @type {IdGenerator}
         */
        this.idGenerator = idGenerator;

        /**
         * A callback function to call when there is a loop.
         * @type {Function}
         */
        this.notifyLooped = onLooped;

        /**
         * The root fork context for this state.
         * @type {ForkContext}
         */
        this.forkContext = F